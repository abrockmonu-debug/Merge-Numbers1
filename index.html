<!DOCTYPE html>
<html>
<head>
    <title>Merge Numbers</title>
    <style>
        body {
            background-color: #333;
            color: #eee;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none; /* Prevents text selection on mobile */
            -webkit-user-select: none; /* For Safari */
            -moz-user-select: none; /* For Firefox */
            -ms-user-select: none; /* For Internet Explorer/Edge */
        }
        canvas {
            border: 2px solid #ccc;
            background-color: #000;
        }
        h1 {
            color: #fff;
            margin-bottom: 20px;
        }
        .controls {
            margin-top: 20px;
            text-align: center;
        }
        .controls p {
            margin: 5px 0;
            font-size: 14px;
        }
    </style>
</head>
<body>

    <h1>Merge Numbers</h1>
    <canvas id="gameCanvas" width="300" height="600"></canvas>

    <div class="controls">
        <p>Swipe **Left** or **Right** to move.</p>
        <p>Tap anywhere to rotate.</p>
        <p>Swipe **Down** to speed up the drop.</p>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const TILE_SIZE = 30;
        const COLUMNS = 10;
        const ROWS = 20;
        const BASE_NUMBERS = [2, 4];
        
        let grid = createGrid();
        let currentPiece = createPiece();
        let nextPiece = createPiece();
        let score = 0;
        let lastTime = 0;
        const DROP_INTERVAL = 1000; // milliseconds
        let dropCounter = 0;
        
        // Touch control variables
        let touchStartX = 0;
        let touchStartY = 0;
        const SWIPE_THRESHOLD = 30; // Min pixels for a swipe
        
        // Piece shapes and colors
        const shapes = [
            [[1]],
            [[1, 1], [1, 1]],
            [[0, 1, 0], [1, 1, 1]],
            [[1, 1, 0], [0, 1, 1]],
            [[0, 1, 1], [1, 1, 0]],
            [[1, 0, 0], [1, 1, 1]],
            [[0, 0, 1], [1, 1, 1]]
        ];
        
        const colors = [
            '#FF6347', '#FFD700', '#ADFF2F', '#00FFFF', '#8A2BE2', '#FF69B4', '#1E90FF'
        ];
        
        function createGrid() {
            return Array.from({length: ROWS}, () => Array(COLUMNS).fill(0));
        }
        
        function createPiece() {
            const shapeIndex = Math.floor(Math.random() * shapes.length);
            const shape = shapes[shapeIndex];
            const number = BASE_NUMBERS[Math.floor(Math.random() * BASE_NUMBERS.length)];
            const color = colors[shapeIndex];
            return {
                matrix: shape,
                pos: { x: Math.floor(COLUMNS / 2) - Math.floor(shape[0].length / 2), y: 0 },
                number: number,
                color: color
            };
        }
        
        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let y = 0; y < grid.length; y++) {
                for (let x = 0; x < grid[y].length; x++) {
                    const number = grid[y][x];
                    if (number) {
                        drawBlock(x, y, number, findColor(number));
                    }
                }
            }
        }
        
        function findColor(number) {
             const colorsMap = {
                2: '#FF6347',
                4: '#FFD700',
                8: '#ADFF2F',
                16: '#00FFFF',
                32: '#8A2BE2',
                64: '#FF69B4',
                128: '#1E90FF',
                256: '#FF4500',
                512: '#DA70D6',
                1024: '#32CD32',
                2048: '#FFDAB9'
            };
            return colorsMap[number] || '#666';
        }
        
        function drawBlock(x, y, number, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            ctx.strokeStyle = '#222';
            ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = `${TILE_SIZE / 2}px Arial`;
            ctx.fillText(number, x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2);
        }
        
        function draw() {
            drawGrid();
            drawPiece(currentPiece);
        }
        
        function drawPiece(piece) {
            piece.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        drawBlock(piece.pos.x + x, piece.pos.y + y, piece.number, piece.color);
                    }
                });
            });
        }
        
        function update(time = 0) {
            const deltaTime = time - lastTime;
            lastTime = time;
            
            dropCounter += deltaTime;
            if (dropCounter > DROP_INTERVAL) {
                dropPiece();
                dropCounter = 0;
            }
            
            draw();
            requestAnimationFrame(update);
        }
        
        function dropPiece() {
            currentPiece.pos.y++;
            if (checkCollision()) {
                currentPiece.pos.y--;
                merge();
                currentPiece = nextPiece;
                nextPiece = createPiece();
                if (checkCollision()) {
                    // Game over logic
                    alert('Game Over! Your score: ' + score);
                    grid = createGrid();
                    score = 0;
                }
            }
        }
        
        function checkCollision() {
            const matrix = currentPiece.matrix;
            const pos = currentPiece.pos;
            for (let y = 0; y < matrix.length; y++) {
                for (let x = 0; x < matrix[y].length; x++) {
                    if (matrix[y][x] !== 0) {
                        const newX = pos.x + x;
                        const newY = pos.y + y;
                        if (newY >= ROWS || newX < 0 || newX >= COLUMNS || grid[newY][newX] !== 0) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        function merge() {
            const matrix = currentPiece.matrix;
            const pos = currentPiece.pos;
            
            for (let y = 0; y < matrix.length; y++) {
                for (let x = 0; x < matrix[y].length; x++) {
                    if (matrix[y][x] !== 0) {
                        const newX = pos.x + x;
                        const newY = pos.y + y;
                        if (newY >= 0 && newY < ROWS && newX >= 0 && newX < COLUMNS) {
                           grid[newY][newX] = currentPiece.number;
                        }
                    }
                }
            }
            
            checkAndMergeNumbers();
        }
        
        function checkAndMergeNumbers() {
            let merged = true;
            while(merged) {
                merged = false;
                for(let y = ROWS - 1; y >= 0; y--) {
                    for(let x = 0; x < COLUMNS; x++) {
                        const current = grid[y][x];
                        if (current === 0) continue;
                        
                        // Check neighbors for merging
                        // Down
                        if (y + 1 < ROWS && grid[y+1][x] === current) {
                            grid[y+1][x] = current * 2;
                            grid[y][x] = 0;
                            score += current * 2;
                            merged = true;
                        }
                        // Right
                        else if (x + 1 < COLUMNS && grid[y][x+1] === current) {
                            grid[y][x+1] = current * 2;
                            grid[y][x] = 0;
                            score += current * 2;
                            merged = true;
                        }
                        // Check if any numbers were merged and fall down
                        if (merged) {
                           gravity();
                        }
                    }
                }
            }
        }
        
        function gravity() {
            for(let x = 0; x < COLUMNS; x++) {
                let emptySpaces = [];
                for(let y = ROWS - 1; y >= 0; y--) {
                    if (grid[y][x] === 0) {
                        emptySpaces.push(y);
                    } else if (emptySpaces.length > 0) {
                        const newY = emptySpaces.shift();
                        grid[newY][x] = grid[y][x];
                        grid[y][x] = 0;
                        emptySpaces.push(y);
                    }
                }
            }
        }
        
        function rotateMatrix(matrix, direction) {
            const rotated = matrix[0].map((val, index) => matrix.map(row => row[index]).reverse());
            if (direction === -1) {
                return rotated.map(row => row.reverse());
            }
            return rotated;
        }
        
        function playerMove(direction) {
            currentPiece.pos.x += direction;
            if (checkCollision()) {
                currentPiece.pos.x -= direction;
            }
        }
        
        function playerRotate() {
            const pos = currentPiece.pos.x;
            let offset = 1;
            const rotatedMatrix = rotateMatrix(currentPiece.matrix, 1);
            while (checkCollision(rotatedMatrix)) {
                currentPiece.pos.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > currentPiece.matrix[0].length) {
                    currentPiece.pos.x = pos;
                    return;
                }
            }
            currentPiece.matrix = rotatedMatrix;
        }
        
        // --- Touch Control Handlers ---
        canvas.addEventListener('touchstart', e => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            e.preventDefault();
        }, false);

        canvas.addEventListener('touchend', e => {
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;

            if (Math.abs(dx) > Math.abs(dy)) {
                // Horizontal swipe
                if (Math.abs(dx) > SWIPE_THRESHOLD) {
                    playerMove(dx > 0 ? 1 : -1);
                }
            } else {
                // Vertical swipe or tap
                if (Math.abs(dy) > SWIPE_THRESHOLD) {
                    // Down swipe
                    if (dy > 0) {
                        dropPiece();
                    }
                } else {
                    // Tap
                    playerRotate();
                }
            }
            e.preventDefault();
        }, false);
        
        update();
    </script>
</body>
</html>
